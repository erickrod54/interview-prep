import { hashtable,
         bigo1stgraph,
         bigo2ndgraph,
         bigo3const,
         bigoconst,
         bigochart,
         hashcollision,
         hashtablesvsarrays,
         linklistcomposition,
         linklistmethodscomplexity, 
         doublylinklistcomposition, 
         doublylinklistmethodscomplexity,
         stacksandmethods,
         queuesandmethods,
         exerciseinasynchronousprocessing,
         asynchronousprocessing,
         treesdatastructure,
         binarytreeconcept,
         kindbinarytrees,
         binarysearchtreeconcept,
         binarysearchtreecomparison,
         binarysearchtreeimplementation,
         unbalancedavltreepng,
         balancedavltree,
         graphs,
         multiplegraphs,
         typesgraphs,
         weightunweightgraphs,
         cyclicacyclicgraph,
         howtoimplementgraphs,
         graphthreewayimplementation,
         adjancentgraph,
         adjancentmatrix,
         adjancentmatrixgraph,
         graphimplementation,
         datastructuresreview,
         datastructureandalgorithms,
         factorialexercise,
         fibonaccirecurssion,
         recursioniterativetradeoffs,
         recursionconversionrule,
         sortingimportance,
         sortelementaryandcomplex,
         sortingfindingscanning,
         selectionswappingelements
         } from './assets/index';      

/**interview-prep-app - version 29.15 - data js - 
 * Features: 
 * 
 *     --> Adding 'selectionswappingelements' for 
 *         graphsData.   
 * 
 * Note: By this point i will start to relate algorithms with
 * data structures.
 */

export const linksData = [
  {
    id:'1',
    url:'/big-o-notation',
    name:'big o notation',   
  },
  {
    id:'2',
    url:'/big-o-rule-book',
    name:'big o rule-book'
  },
  {
    id:'3',
    url:'/space-complexity',
    name:'space complexity'
  },
  {
    id:'4',
    url:'/how-to-solve-problems',
    name:'how to solve problems'
  },
  {
    id:'5',
    url:'/data-structures-and-algorithms',
    name:'data structures and algorithms'
  },
  {
    id:'6',
    name:'arrays'
  },
  {
    id:'7',
    name:'static arrays vs dynamic arrays'
  },
  {
    id:'8',
    name:'arrays implementation'
  },
  {
    id:'9',
    name:'Build and use Arrays'
  },
  {
    id:'10',
    name:'Hash Tables'
  },
  {
    id:'11',
    name:'hash collisions'
  },
  {
    id:'12',
      name:'how to build hash tables'
    },
    {
      id:'13',
      name:'Interview QA'
    },
    {
      id:'14',
      name:'linked lists'
    },
    {
      id:'15',
      name:'doubly linked lists'
     },
     {
       id:'16',
       name:'stack & queues'
      },
      {
        id:'17',
        name:'stacks and linkedList'
       },
      {
        id:'18',
        name:'queues and linkedList'
      },
      {
        id:'19',
        name:'Tree Data Structure'
      },
      {
        id:'20',
        name:'BTS implementation'
      },
      {
        id:'21',
        name:'BTS balanced'
      },
      {
        id:'22',
        name:'Graphs Data Structure'
      },
      {
        id:'23',
        name:'Graphs Implementation'
      },
      {
        id:'24',
        name:'Algorithhms Intro'
      },
      {
        id:'25',
        name:'Sorting'
      },
      /**{
        id:'26',
        name:'Dynamic Programming'
      },
      {
        id:'27',
        name:'BFS + DFS ( Searching )'
      },
      {
        id:'24',
        name:'Recursion'
      }, */     
    ]
    
    
    
    export const nemo = ['nemo'];
    
    export const graphsData = [
      {
        id:1,
        image:bigo1stgraph
      },
      {
        id:2,
        image:bigo2ndgraph
      },
      {
        id:3,
        image:bigoconst
      },
      {
        id:4,
        image:bigo3const
      },
      {
        id:5,
        image:bigochart
      },
      {
        id:6,
        image:hashcollision
      },
      {
        id:7,
        image: hashtable
      },
      {
        id:8,
        image: hashtablesvsarrays
      },
      {
        id:9,
        image:linklistcomposition
      },
      {
        id:10,
        image:linklistmethodscomplexity
      },
      {
        id:11,
        image:doublylinklistcomposition
      },
      {
        id:12,
        image: doublylinklistmethodscomplexity
      },
      {
        id:13,
        image: stacksandmethods
      },
      {
        id:14,
        image: queuesandmethods
      },
      {
        id:15,
        image:asynchronousprocessing
      },
      {
        id:16,
        image:exerciseinasynchronousprocessing
      },
      {
        id:17,
        image:treesdatastructure
      },
      {
        id:18,
        image:binarytreeconcept
      },
      {
        id:19,
        image: kindbinarytrees
      },
      {
        id:20,
        image: binarysearchtreeconcept
      },
      {
        id:21,
        image: binarysearchtreecomparison
      },
      {
        id:22,
        image: binarysearchtreeimplementation
      },
      {
        id:23,
        image: unbalancedavltreepng
      },
      {
        id:24,
        image: balancedavltree
      },
      {
        id:25,
        image: graphs
      },
      {
        id:26,
        image: multiplegraphs
      },
      {
        id:27,
        image: typesgraphs
      },
      {
        id:28,
        image: weightunweightgraphs
      },
      {
        id:29,
        image: cyclicacyclicgraph
      },
      {
        id:30,
        image: howtoimplementgraphs
      },
      {
        id:31,
        image: graphthreewayimplementation
      },
      {
        id:32,
        image: adjancentgraph
      },
      {
        id:33,
        image: adjancentmatrix
      },
      {
        id:34,
        image: adjancentmatrixgraph
      },
      {
        id:35,
        image: graphimplementation
      },
      {
        id:36,
        image: datastructuresreview
      },
      {
        id:37,
        image: datastructureandalgorithms
      },
      {
        id:38,
        image: factorialexercise
      },
      {
        id:39,
        image: fibonaccirecurssion
      },
      {
        id:40,
        image: recursioniterativetradeoffs
      },
      {
        id:41,
        image: recursionconversionrule
      },
      {
        id:42,
        image: sortingimportance
      },
      {
        id:43,
        image: sortelementaryandcomplex
      },
      {
        id:44,
        image: sortingfindingscanning
      },
      {
        id:45,
        image: selectionswappingelements
      }  
    ]
    
    export const everyoneCharacter = [
      'dory',
      'bruce',
      'marlin',
      'nemo',
      'gill',
      'bloat',
      'nigel',
      'squirt',
      'darla',
      'hank'
]

export const largeArray = new Array(1000).fill('nemo')

export const boxes = [1,2,3,4,5]

export const boxes1 = [1,2,3,4,5,6,7,8]

export const boxesletters = [ 'a','b','c','d','e']

export const numbers = [1,2,3,4,5]

export const n = [1,2,3,4,5]


export const array1 = [ 'a', 'b', 'c', 'x']

export const array2 = [ 'z', 'y', 'i' ]

export const array3 = [ 'a', 'b', 'c', 'x']

export const array4 = [ 'a', 'y', 'x']

/**data for interview.questions.jsx */

//Google question first recurrent number

//Given an array

//it should return 2
export const array5 = [ 2,5,1,2,3,5,1,2,4 ]

//it should return 1
export const array6 = [ 2,1,1,2,3,5,1,2,4 ]

//it should return undefined
export const array7 = [ 2,3,4,5 ]

/**linked list data */

/**example array to linked list */
export const basket = ['apples', 'grapes', 'pears']


